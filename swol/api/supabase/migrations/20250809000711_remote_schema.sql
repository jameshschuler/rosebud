create table "public"."activity" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null
);


alter table "public"."activity" enable row level security;

create table "public"."gym_checkin" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "user_id" uuid not null,
    "checkin_date" timestamp with time zone not null,
    "activity_id" bigint not null default '1'::bigint
);


alter table "public"."gym_checkin" enable row level security;

create table "public"."programs" (
    "id" bigint generated by default as identity not null,
    "name" text not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp without time zone,
    "description" text,
    "user_id" uuid not null,
    "program_type" text not null,
    "active" boolean not null,
    "author" text not null
);


alter table "public"."programs" enable row level security;

create table "public"."user_profile" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "user_id" uuid not null,
    "email" character varying not null,
    "full_name" character varying,
    "avatar_url" character varying,
    "picture_url" character varying,
    "username" character varying,
    "updated_at" timestamp with time zone,
    "synced_profile" boolean not null default false
);


alter table "public"."user_profile" enable row level security;

CREATE UNIQUE INDEX activity_pkey ON public.activity USING btree (id);

CREATE UNIQUE INDEX gym_checkin_pkey ON public.gym_checkin USING btree (id);

CREATE UNIQUE INDEX programs_pkey ON public.programs USING btree (id);

CREATE UNIQUE INDEX user_profile_email_key ON public.user_profile USING btree (email);

CREATE UNIQUE INDEX user_profile_pkey ON public.user_profile USING btree (id);

CREATE UNIQUE INDEX user_profile_user_id_key ON public.user_profile USING btree (user_id);

alter table "public"."activity" add constraint "activity_pkey" PRIMARY KEY using index "activity_pkey";

alter table "public"."gym_checkin" add constraint "gym_checkin_pkey" PRIMARY KEY using index "gym_checkin_pkey";

alter table "public"."programs" add constraint "programs_pkey" PRIMARY KEY using index "programs_pkey";

alter table "public"."user_profile" add constraint "user_profile_pkey" PRIMARY KEY using index "user_profile_pkey";

alter table "public"."gym_checkin" add constraint "gym_checkin_activity_id_fkey" FOREIGN KEY (activity_id) REFERENCES public.activity(id) not valid;

alter table "public"."gym_checkin" validate constraint "gym_checkin_activity_id_fkey";

alter table "public"."gym_checkin" add constraint "gym_checkin_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."gym_checkin" validate constraint "gym_checkin_user_id_fkey";

alter table "public"."programs" add constraint "programs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."programs" validate constraint "programs_user_id_fkey";

alter table "public"."user_profile" add constraint "user_profile_email_key" UNIQUE using index "user_profile_email_key";

alter table "public"."user_profile" add constraint "user_profile_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."user_profile" validate constraint "user_profile_user_id_fkey";

alter table "public"."user_profile" add constraint "user_profile_user_id_key" UNIQUE using index "user_profile_user_id_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.delete_claim(uid uuid, claim text)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN 'error: access denied';
      ELSE        
        update auth.users set raw_app_meta_data = 
          raw_app_meta_data - claim where id = uid;
        return 'OK';
      END IF;
    END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_claim(uid uuid, claim text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
    DECLARE retval jsonb;
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN '{"error":"access denied"}'::jsonb;
      ELSE
        select coalesce(raw_app_meta_data->claim, null) from auth.users into retval where id = uid::uuid;
        return retval;
      END IF;
    END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_claims(uid uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
    DECLARE retval jsonb;
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN '{"error":"access denied"}'::jsonb;
      ELSE
        select raw_app_meta_data from auth.users into retval where id = uid::uuid;
        return retval;
      END IF;
    END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_claim(claim text)
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
  	coalesce(nullif(current_setting('request.jwt.claims', true), '')::jsonb -> 'app_metadata' -> claim, null)
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_claims()
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
  	coalesce(nullif(current_setting('request.jwt.claims', true), '')::jsonb -> 'app_metadata', '{}'::jsonb)::jsonb
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.user_profile (user_id, email)
  values (new.id, new.email);
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.is_claims_admin()
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
  BEGIN
    IF session_user = 'authenticator' THEN
      --------------------------------------------
      -- To disallow any authenticated app users
      -- from editing claims, delete the following
      -- block of code and replace it with:
      -- RETURN FALSE;
      --------------------------------------------
      IF extract(epoch from now()) > coalesce((current_setting('request.jwt.claims', true)::jsonb)->>'exp', '0')::numeric THEN
        return false; -- jwt expired
      END IF;
      If current_setting('request.jwt.claims', true)::jsonb->>'role' = 'service_role' THEN
        RETURN true; -- service role users have admin rights
      END IF;
      IF coalesce((current_setting('request.jwt.claims', true)::jsonb)->'app_metadata'->'claims_admin', 'false')::bool THEN
        return true; -- user has claims_admin set to true
      ELSE
        return false; -- user does NOT have claims_admin set to true
      END IF;
      --------------------------------------------
      -- End of block 
      --------------------------------------------
    ELSE -- not a user session, probably being called from a trigger or something
      return true;
    END IF;
  END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_claim(uid uuid, claim text, value jsonb)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN 'error: access denied';
      ELSE        
        update auth.users set raw_app_meta_data = 
          raw_app_meta_data || 
            json_build_object(claim, value)::jsonb where id = uid;
        return 'OK';
      END IF;
    END;
$function$
;

create policy "Enable select for authenticated users only"
on "public"."activity"
as permissive
for select
to authenticated
using (true);


create policy "Prevent all DELETE operations"
on "public"."activity"
as permissive
for delete
to public
using (false);


create policy "Prevent all Inserts"
on "public"."activity"
as permissive
for insert
to public
with check (false);


create policy "Prevent all UPDATE operations"
on "public"."activity"
as permissive
for update
to public
using (false);


create policy "Deny all access to anon"
on "public"."gym_checkin"
as restrictive
for all
to anon
using (false);


create policy "Enable delete for users based on user_id"
on "public"."gym_checkin"
as permissive
for delete
to authenticated
using (( SELECT (auth.uid() = gym_checkin.user_id)));


create policy "Enable insert for authenticated users only"
on "public"."gym_checkin"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable select for users based on user_id"
on "public"."gym_checkin"
as permissive
for select
to authenticated
using ((auth.uid() = user_id));


create policy "Enable update for users based on user_id"
on "public"."gym_checkin"
as permissive
for update
to authenticated
using ((auth.uid() = user_id));


create policy "Deny all access to anon"
on "public"."programs"
as restrictive
for all
to anon
using (false);


create policy "Enable all operations for users based on user_id"
on "public"."programs"
as restrictive
for all
to authenticated
using ((auth.uid() = user_id))
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Disable delete"
on "public"."user_profile"
as permissive
for delete
to public
using (false);


create policy "Enable select for users based on user_id"
on "public"."user_profile"
as permissive
for select
to authenticated
using ((auth.uid() = user_id));


create policy "Enable update for users based on user_id"
on "public"."user_profile"
as permissive
for update
to authenticated
using ((auth.uid() = user_id));



